<!DOCTYPE html>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<html>
<head>
<title>/home/xinniw/Documents/garden/Functional Core, Imperative
Shell.md</title>
<link rel="stylesheet" href="style.css">
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<meta http-equiv="Content-Type" content="text/html">
</head>
<body>
<div>
    <a href="index.html">index</a> > /home/xinniw/Documents/garden/Functional
Core, Imperative Shell.md
    </div>
<hr />
<h1 id="functional-core-imperative-shell">Functional Core, Imperative
Shell</h1>
<p>:cc0:</p>
<p>Functional Core, Imperative Shell is a software architecture pattern
that I was first exposed to by watching a talk by <a
href="https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell">Destroy
All Software</a>. Systems organized according to this principle place as
much business logic as possible inside of pure, <a
href="Referential%20Transparency.html">referentially transparent</a>
functions and places all interaction with the outside world in
imperative routines and/or object oriented classes. In theory, a system
organized this way gains much of the benefits of a pure functional
system without the mental/mathematical gymnastics required to write pure
functional code whose purpose is to generate/organize side effects. (ex.
Monads, monoids, endofunctors, ect...) As the system's internals are
pure, they can be tested without mock objects or collaborators. The
systems unit tests are then more accurately measuring the production
behavior and are independent of internal implementation. The outer layer
may be tested using mock versions of the functions contained within.</p>
<hr />
<div>
    <a href="index.html">index</a> > /home/xinniw/Documents/garden/Functional
Core, Imperative Shell.md
      </ol>
    </div>
	</div>
</body>
</html>
